As an alternative to the stand-alone client, this optional PoC diff
integrates ldapclient into OpenBSD's ldapctl(8) (ldapctl search ...).

Index: usr.sbin/ldapctl/Makefile
===================================================================
RCS file: /cvs/src/usr.sbin/ldapctl/Makefile,v
retrieving revision 1.9
diff -u -p -u -p -r1.9 Makefile
--- usr.sbin/ldapctl/Makefile	3 Jul 2017 22:21:47 -0000	1.9
+++ usr.sbin/ldapctl/Makefile	15 May 2018 12:58:18 -0000
@@ -6,6 +6,7 @@ PROG=		ldapctl
 MAN=		ldapctl.8
 SRCS=		ldapctl.c parse.y btree.c log.c logmsg.c ber.c util.c \
 		index.c attributes.c schema.c syntax.c matching.c
+SRCS+=		ldapclient.c aldap.c
 
 LDADD=		-levent -ltls -lssl -lcrypto -lz -lutil
 DPADD=		${LIBEVENT} ${LIBTLS} ${LIBSSL} ${LIBCRYPTO} ${LIBZ} ${LIBUTIL}
Index: usr.sbin/ldapctl/aldap.c
===================================================================
RCS file: usr.sbin/ldapctl/aldap.c
diff -N usr.sbin/ldapctl/aldap.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ usr.sbin/ldapctl/aldap.c	15 May 2018 12:58:18 -0000
@@ -0,0 +1,1387 @@
+/*	$OpenBSD: aldap.c,v 1.39 2018/02/08 18:02:06 jca Exp $ */
+
+/*
+ * Copyright (c) 2008 Alexander Schrijver <aschrijver@openbsd.org>
+ * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <arpa/inet.h>
+#include <ctype.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <event.h>
+
+#include "aldap.h"
+
+#if 0
+#define DEBUG
+#endif
+#define VERSION 3
+
+static struct ber_element	*ldap_parse_search_filter(struct ber_element *,
+				    char *);
+static struct ber_element	*ldap_do_parse_search_filter(
+				    struct ber_element *, char **);
+char				**aldap_get_stringset(struct ber_element *);
+char				*utoa(char *);
+static int			 isu8cont(unsigned char);
+char				*parseval(char *, size_t);
+int				aldap_create_page_control(struct ber_element *,
+				    int, struct aldap_page_control *);
+int				aldap_send(struct aldap *,
+				    struct ber_element *);
+unsigned long			aldap_application(struct ber_element *);
+
+#ifdef DEBUG
+void			 ldap_debug_elements(struct ber_element *);
+#endif
+
+#ifdef DEBUG
+#define DPRINTF(x...)	printf(x)
+#define LDAP_DEBUG(x, y)	do { fprintf(stderr, "*** " x "\n"); ldap_debug_elements(y); } while (0)
+#else
+#define DPRINTF(x...)	do { } while (0)
+#define LDAP_DEBUG(x, y)	do { } while (0)
+#endif
+
+unsigned long
+aldap_application(struct ber_element *elm)
+{
+	return BER_TYPE_OCTETSTRING;
+}
+
+int
+aldap_close(struct aldap *al)
+{
+	if (al->tls != NULL) {
+		tls_close(al->tls);
+		tls_free(al->tls);
+	}
+	close(al->fd);
+	ber_free(&al->ber);
+	evbuffer_free(al->buf);
+	free(al);
+
+	return (0);
+}
+
+struct aldap *
+aldap_init(int fd)
+{
+	struct aldap *a;
+
+	if ((a = calloc(1, sizeof(*a))) == NULL)
+		return NULL;
+	a->buf = evbuffer_new();
+	a->fd = fd;
+	ber_set_application(&a->ber, aldap_application);
+
+	return a;
+}
+
+int
+aldap_tls(struct aldap *ldap, struct tls_config *cfg, const char *name)
+{
+	ldap->tls = tls_client();
+	if (ldap->tls == NULL) {
+		ldap->err = ALDAP_ERR_OPERATION_FAILED;
+		return (-1);
+	}
+
+	if (tls_configure(ldap->tls, cfg) == -1) {
+		ldap->err = ALDAP_ERR_TLS_ERROR;
+		return (-1);
+	}
+
+	if (tls_connect_socket(ldap->tls, ldap->fd, name) == -1) {
+		ldap->err = ALDAP_ERR_TLS_ERROR;
+		return (-1);
+	}
+
+	if (tls_handshake(ldap->tls) == -1) {
+		ldap->err = ALDAP_ERR_TLS_ERROR;
+		return (-1);
+	}
+
+	return (0);
+}
+
+int
+aldap_send(struct aldap *ldap, struct ber_element *root)
+{
+	int error, wrote;
+	void *ptr;
+	char *data;
+	size_t len, done;
+
+	len = ber_calc_len(root);
+	error = ber_write_elements(&ldap->ber, root);
+	ber_free_elements(root);
+	if (error == -1)
+		return -1;
+
+	ber_get_writebuf(&ldap->ber, &ptr);
+	done = 0;
+	data = ptr;
+	while (len > 0) {
+		if (ldap->tls != NULL) {
+			wrote = tls_write(ldap->tls, data + done, len);
+			if (wrote == TLS_WANT_POLLIN ||
+			    wrote == TLS_WANT_POLLOUT)
+				continue;
+		} else
+			wrote = write(ldap->fd, data + done, len);
+
+		if (wrote == -1)
+			return -1;
+
+		len -= wrote;
+		done += wrote;
+	}
+
+	return 0;
+}
+
+int
+aldap_req_starttls(struct aldap *ldap)
+{
+	struct ber_element *root = NULL, *ber;
+
+	if ((root = ber_add_sequence(NULL)) == NULL)
+		goto fail;
+
+	ber = ber_printf_elements(root, "d{tst", ++ldap->msgid, BER_CLASS_APP,
+	    (unsigned long) LDAP_REQ_EXTENDED, LDAP_STARTTLS_OID,
+	    BER_CLASS_CONTEXT, (unsigned long) 0);
+	if (ber == NULL) {
+		ldap->err = ALDAP_ERR_OPERATION_FAILED;
+		goto fail;
+	}
+
+	if (aldap_send(ldap, root) == -1)
+		goto fail;
+
+	return (ldap->msgid);
+fail:
+	if (root != NULL)
+		ber_free_elements(root);
+
+	ldap->err = ALDAP_ERR_OPERATION_FAILED;
+	return (-1);
+}
+
+int
+aldap_bind(struct aldap *ldap, char *binddn, char *bindcred)
+{
+	struct ber_element *root = NULL, *elm;
+
+	if (binddn == NULL)
+		binddn = "";
+	if (bindcred == NULL)
+		bindcred = "";
+
+	if ((root = ber_add_sequence(NULL)) == NULL)
+		goto fail;
+
+	elm = ber_printf_elements(root, "d{tdsst", ++ldap->msgid, BER_CLASS_APP,
+	    (unsigned long)LDAP_REQ_BIND, VERSION, binddn, bindcred,
+	    BER_CLASS_CONTEXT, (unsigned long)LDAP_AUTH_SIMPLE);
+	if (elm == NULL)
+		goto fail;
+
+	LDAP_DEBUG("aldap_bind", root);
+
+	if (aldap_send(ldap, root) == -1) {
+		root = NULL;
+		goto fail;
+	}
+	return (ldap->msgid);
+fail:
+	if (root != NULL)
+		ber_free_elements(root);
+
+	ldap->err = ALDAP_ERR_OPERATION_FAILED;
+	return (-1);
+}
+
+int
+aldap_unbind(struct aldap *ldap)
+{
+	struct ber_element *root = NULL, *elm;
+
+	if ((root = ber_add_sequence(NULL)) == NULL)
+		goto fail;
+	elm = ber_printf_elements(root, "d{t", ++ldap->msgid, BER_CLASS_APP,
+	    LDAP_REQ_UNBIND_30);
+	if (elm == NULL)
+		goto fail;
+
+	LDAP_DEBUG("aldap_unbind", root);
+
+	if (aldap_send(ldap, root) == -1) {
+		root = NULL;
+		goto fail;
+	}
+	return (ldap->msgid);
+fail:
+	if (root != NULL)
+		ber_free_elements(root);
+
+	ldap->err = ALDAP_ERR_OPERATION_FAILED;
+
+	return (-1);
+}
+
+int
+aldap_search(struct aldap *ldap, char *basedn, enum scope scope, char *filter,
+    char **attrs, int typesonly, int sizelimit, int timelimit,
+    struct aldap_page_control *page)
+{
+	struct ber_element *root = NULL, *ber, *c;
+	int i;
+
+	if ((root = ber_add_sequence(NULL)) == NULL)
+		goto fail;
+
+	ber = ber_printf_elements(root, "d{t", ++ldap->msgid, BER_CLASS_APP,
+	    (unsigned long) LDAP_REQ_SEARCH);
+	if (ber == NULL) {
+		ldap->err = ALDAP_ERR_OPERATION_FAILED;
+		goto fail;
+	}
+
+	c = ber;	
+	ber = ber_printf_elements(ber, "sEEddb", basedn, (long long)scope,
+	                         (long long)LDAP_DEREF_NEVER, sizelimit, 
+				 timelimit, typesonly);
+	if (ber == NULL) {
+		ldap->err = ALDAP_ERR_OPERATION_FAILED;
+		goto fail;
+	}
+
+	if ((ber = ldap_parse_search_filter(ber, filter)) == NULL) {
+		ldap->err = ALDAP_ERR_PARSER_ERROR;
+		goto fail;
+	}
+
+	if ((ber = ber_add_sequence(ber)) == NULL)
+		goto fail;
+	if (attrs != NULL)
+		for (i = 0; attrs[i] != NULL; i++) {
+			if ((ber = ber_add_string(ber, attrs[i])) == NULL)
+				goto fail;
+		}
+
+	aldap_create_page_control(c, 100, page);
+
+	LDAP_DEBUG("aldap_search", root);
+
+	if (aldap_send(ldap, root) == -1) {
+		root = NULL;
+		ldap->err = ALDAP_ERR_OPERATION_FAILED;
+		goto fail;
+	}
+
+	return (ldap->msgid);
+
+fail:
+	if (root != NULL)
+		ber_free_elements(root);
+
+	return (-1);
+}
+
+int
+aldap_create_page_control(struct ber_element *elm, int size,
+    struct aldap_page_control *page)
+{
+	int len;
+	struct ber c;
+	struct ber_element *ber = NULL;
+
+	c.br_wbuf = NULL;
+
+	ber = ber_add_sequence(NULL);
+
+	if (page == NULL) {
+		if (ber_printf_elements(ber, "ds", 50, "") == NULL)
+			goto fail;
+	} else {
+		if (ber_printf_elements(ber, "dx", 50, page->cookie,
+			    page->cookie_len) == NULL)
+			goto fail;
+	}
+
+	if ((len = ber_write_elements(&c, ber)) < 1)
+		goto fail;
+	if (ber_printf_elements(elm, "{t{sx", 2, 0, LDAP_PAGED_OID,
+		                c.br_wbuf, (size_t)len) == NULL)
+		goto fail;
+
+	ber_free_elements(ber);
+	ber_free(&c);
+	return len;
+fail:
+	if (ber != NULL)
+		ber_free_elements(ber);
+	ber_free(&c);	
+
+	return (-1);
+}
+
+struct aldap_message *
+aldap_parse(struct aldap *ldap)
+{
+	int			 class;
+	unsigned long		 type;
+	long long		 msgid = 0;
+	struct aldap_message	*m;
+	struct ber_element	*a = NULL, *ep;
+	char			 rbuf[512];
+	int			 ret, retry;
+
+	if ((m = calloc(1, sizeof(struct aldap_message))) == NULL)
+		return NULL;
+
+	retry = 0;
+	while (m->msg == NULL) {
+		if (retry || EVBUFFER_LENGTH(ldap->buf) == 0) {
+			if (ldap->tls) {
+				ret = tls_read(ldap->tls, rbuf, sizeof(rbuf));
+				if (ret == TLS_WANT_POLLIN ||
+				    ret == TLS_WANT_POLLOUT)
+					continue;
+			} else
+				ret = read(ldap->fd, rbuf, sizeof(rbuf));
+
+			if (ret == -1) {
+				goto parsefail;
+			}
+
+			evbuffer_add(ldap->buf, rbuf, ret);
+		}
+
+		if (EVBUFFER_LENGTH(ldap->buf) > 0) {
+			ber_set_readbuf(&ldap->ber, EVBUFFER_DATA(ldap->buf),
+			    EVBUFFER_LENGTH(ldap->buf));
+			errno = 0;
+			m->msg = ber_read_elements(&ldap->ber, NULL);
+			if (errno != 0 && errno != ECANCELED) {
+				goto parsefail;
+			}
+
+			retry = 1;
+		}
+	}
+
+	evbuffer_drain(ldap->buf, ldap->ber.br_rptr - ldap->ber.br_rbuf);
+
+	LDAP_DEBUG("message", m->msg);
+
+	if (ber_scanf_elements(m->msg, "{ite", &msgid, &class, &type, &a) != 0)
+		goto parsefail;
+	m->msgid = msgid;
+	m->message_type = type;
+	m->protocol_op = a;
+
+	switch (m->message_type) {
+	case LDAP_RES_BIND:
+	case LDAP_RES_MODIFY:
+	case LDAP_RES_ADD:
+	case LDAP_RES_DELETE:
+	case LDAP_RES_MODRDN:
+	case LDAP_RES_COMPARE:
+	case LDAP_RES_SEARCH_RESULT:
+		if (ber_scanf_elements(m->protocol_op, "{EeSeSe",
+		    &m->body.res.rescode, &m->dn, &m->body.res.diagmsg, &a) != 0)
+			goto parsefail;
+		if (m->body.res.rescode == LDAP_REFERRAL)
+			if (ber_scanf_elements(a, "{e", &m->references) != 0)
+				goto parsefail;
+		if (m->msg->be_sub) {
+			for (ep = m->msg->be_sub; ep != NULL; ep = ep->be_next) {
+				ber_scanf_elements(ep, "t", &class, &type);
+				if (class == 2 && type == 0)
+					m->page = aldap_parse_page_control(ep->be_sub->be_sub,
+					    ep->be_sub->be_sub->be_len);
+			}
+		} else
+			m->page = NULL;
+		break;
+	case LDAP_RES_SEARCH_ENTRY:
+		if (ber_scanf_elements(m->protocol_op, "{eS{e", &m->dn,
+		    &m->body.search.attrs) != 0)
+			goto parsefail;
+		break;
+	case LDAP_RES_SEARCH_REFERENCE:
+		if (ber_scanf_elements(m->protocol_op, "{e", &m->references) != 0)
+			goto parsefail;
+		break;
+	case LDAP_RES_EXTENDED:
+		if (ber_scanf_elements(m->protocol_op, "{E",
+		    &m->body.res.rescode) != 0) {
+			goto parsefail;
+		}
+		break;
+	}
+
+	return m;
+parsefail:
+	evbuffer_drain(ldap->buf, EVBUFFER_LENGTH(ldap->buf));
+	ldap->err = ALDAP_ERR_PARSER_ERROR;
+	aldap_freemsg(m);
+	return NULL;
+}
+
+struct aldap_page_control *
+aldap_parse_page_control(struct ber_element *control, size_t len) 
+{
+	char *oid, *s;
+	char *encoded;
+	struct ber b;
+	struct ber_element *elm;
+	struct aldap_page_control *page;
+
+	b.br_wbuf = NULL;
+	ber_scanf_elements(control, "ss", &oid, &encoded);
+	ber_set_readbuf(&b, encoded, control->be_next->be_len);
+	elm = ber_read_elements(&b, NULL);
+
+	if ((page = malloc(sizeof(struct aldap_page_control))) == NULL) {
+		if (elm != NULL)
+			ber_free_elements(elm);
+		ber_free(&b);
+		return NULL;
+	}
+
+	ber_scanf_elements(elm->be_sub, "is", &page->size, &s);
+	page->cookie_len = elm->be_sub->be_next->be_len;
+
+	if ((page->cookie = malloc(page->cookie_len)) == NULL) {
+		if (elm != NULL)
+			ber_free_elements(elm);
+		ber_free(&b);
+		free(page);
+		return NULL;
+	}
+	memcpy(page->cookie, s, page->cookie_len);
+
+	ber_free_elements(elm);
+	ber_free(&b);
+	return page;
+}
+
+void
+aldap_freepage(struct aldap_page_control *page)
+{
+	free(page->cookie);
+	free(page);
+}
+
+void
+aldap_freemsg(struct aldap_message *msg)
+{
+	if (msg->msg)
+		ber_free_elements(msg->msg);
+	free(msg);
+}
+
+int
+aldap_get_resultcode(struct aldap_message *msg)
+{
+	return msg->body.res.rescode;
+}
+
+char *
+aldap_get_dn(struct aldap_message *msg)
+{
+	char *dn;
+
+	if (msg->dn == NULL)
+		return NULL;
+
+	if (ber_get_string(msg->dn, &dn) == -1)
+		return NULL;
+
+	return utoa(dn);
+}
+
+char **
+aldap_get_references(struct aldap_message *msg)
+{
+	if (msg->references == NULL)
+		return NULL;
+	return aldap_get_stringset(msg->references);
+}
+
+void
+aldap_free_references(char **values)
+{
+	int i;
+
+	if (values == NULL)
+		return;
+
+	for (i = 0; values[i] != NULL; i++)
+		free(values[i]);
+
+	free(values);
+}
+
+char *
+aldap_get_diagmsg(struct aldap_message *msg)
+{
+	char *s;
+
+	if (msg->body.res.diagmsg == NULL)
+		return NULL;
+
+	if (ber_get_string(msg->body.res.diagmsg, &s) == -1)
+		return NULL;
+
+	return utoa(s);
+}
+
+int
+aldap_count_attrs(struct aldap_message *msg)
+{
+	int i;
+	struct ber_element *a;
+
+	if (msg->body.search.attrs == NULL)
+		return (-1);
+
+	for (i = 0, a = msg->body.search.attrs;
+	    a != NULL && ber_get_eoc(a) != 0;
+	    i++, a = a->be_next)
+		;
+
+	return i;
+}
+
+int
+aldap_first_attr(struct aldap_message *msg, char **outkey, char ***outvalues)
+{
+	struct ber_element *b, *c;
+	char *key;
+	char **ret;
+
+	if (msg->body.search.attrs == NULL)
+		goto fail;
+
+	if (ber_scanf_elements(msg->body.search.attrs, "{s(e)}e",
+	    &key, &b, &c) != 0)
+		goto fail;
+
+	msg->body.search.iter = msg->body.search.attrs->be_next;
+
+	if ((ret = aldap_get_stringset(b)) == NULL)
+		goto fail;
+
+	(*outvalues) = ret;
+	(*outkey) = utoa(key);
+
+	return (1);
+fail:
+	(*outkey) = NULL;
+	(*outvalues) = NULL;
+	return (-1);
+}
+
+int
+aldap_next_attr(struct aldap_message *msg, char **outkey, char ***outvalues)
+{
+	struct ber_element *a, *b;
+	char *key;
+	char **ret;
+
+	if (msg->body.search.iter == NULL)
+		goto notfound;
+
+	LDAP_DEBUG("attr", msg->body.search.iter);
+
+	if (ber_get_eoc(msg->body.search.iter) == 0)
+		goto notfound;
+
+	if (ber_scanf_elements(msg->body.search.iter, "{s(e)}e", &key, &a, &b)
+	    != 0)
+		goto fail;
+
+	msg->body.search.iter = msg->body.search.iter->be_next;
+
+	if ((ret = aldap_get_stringset(a)) == NULL)
+		goto fail;
+
+	(*outvalues) = ret;
+	(*outkey) = utoa(key);
+
+	return (1);
+fail:
+notfound:
+	(*outkey) = NULL;
+	(*outvalues) = NULL;
+	return (-1);
+}
+
+int
+aldap_match_attr(struct aldap_message *msg, char *inkey, char ***outvalues)
+{
+	struct ber_element *a, *b;
+	char *descr = NULL;
+	char **ret;
+
+	if (msg->body.search.attrs == NULL)
+		goto fail;
+
+	LDAP_DEBUG("attr", msg->body.search.attrs);
+
+	for (a = msg->body.search.attrs;;) {
+		if (a == NULL)
+			goto notfound;
+		if (ber_get_eoc(a) == 0)
+			goto notfound;
+		if (ber_scanf_elements(a, "{s(e", &descr, &b) != 0)
+			goto fail;
+		if (strcasecmp(descr, inkey) == 0)
+			goto attrfound;
+		a = a->be_next;
+	}
+
+attrfound:
+	if ((ret = aldap_get_stringset(b)) == NULL)
+		goto fail;
+
+	(*outvalues) = ret;
+
+	return (1);
+fail:
+notfound:
+	(*outvalues) = NULL;
+	return (-1);
+}
+
+int
+aldap_free_attr(char **values)
+{
+	int i;
+
+	if (values == NULL)
+		return -1;
+
+	for (i = 0; values[i] != NULL; i++)
+		free(values[i]);
+
+	free(values);
+
+	return (1);
+}
+
+#if 0
+void
+aldap_free_url(struct aldap_url *lu)
+{
+	free(lu->buffer);
+	free(lu->filter);
+}
+
+int
+aldap_parse_url(char *url, struct aldap_url *lu)
+{
+	char		*p, *forward, *forward2;
+	const char	*errstr = NULL;
+	int		 i;
+
+	if ((lu->buffer = p = strdup(url)) == NULL)
+		return (-1);
+
+	/* protocol */
+	if (strncasecmp(LDAP_URL, p, strlen(LDAP_URL)) != 0)
+		goto fail;
+	lu->protocol = LDAP;
+	p += strlen(LDAP_URL);
+
+	/* host and optional port */
+	if ((forward = strchr(p, '/')) != NULL)
+		*forward = '\0';
+	/* find the optional port */
+	if ((forward2 = strchr(p, ':')) != NULL) {
+		*forward2 = '\0';
+		/* if a port is given */
+		if (*(forward2+1) != '\0') {
+#define PORT_MAX UINT16_MAX
+			lu->port = strtonum(++forward2, 0, PORT_MAX, &errstr);
+			if (errstr)
+				goto fail;
+		}
+	}
+	/* fail if no host is given */
+	if (strlen(p) == 0)
+		goto fail;
+	lu->host = p;
+	if (forward == NULL)
+		goto done;
+	/* p is assigned either a pointer to a character or to '\0' */
+	p = ++forward;
+	if (strlen(p) == 0)
+		goto done;
+
+	/* dn */
+	if ((forward = strchr(p, '?')) != NULL)
+		*forward = '\0';
+	lu->dn = p;
+	if (forward == NULL)
+		goto done;
+	/* p is assigned either a pointer to a character or to '\0' */
+	p = ++forward;
+	if (strlen(p) == 0)
+		goto done;
+
+	/* attributes */
+	if ((forward = strchr(p, '?')) != NULL)
+		*forward = '\0';
+	for (i = 0; i < MAXATTR; i++) {
+		if ((forward2 = strchr(p, ',')) == NULL) {
+			if (strlen(p) == 0)
+				break;
+			lu->attributes[i] = p;
+			break;
+		}
+		*forward2 = '\0';
+		lu->attributes[i] = p;
+		p = ++forward2;
+	}
+	if (forward == NULL)
+		goto done;
+	/* p is assigned either a pointer to a character or to '\0' */
+	p = ++forward;
+	if (strlen(p) == 0)
+		goto done;
+
+	/* scope */
+	if ((forward = strchr(p, '?')) != NULL)
+		*forward = '\0';
+	if (strcmp(p, "base") == 0)
+		lu->scope = LDAP_SCOPE_BASE;
+	else if (strcmp(p, "one") == 0)
+		lu->scope = LDAP_SCOPE_ONELEVEL;
+	else if (strcmp(p, "sub") == 0)
+		lu->scope = LDAP_SCOPE_SUBTREE;
+	else
+		goto fail;
+	if (forward == NULL)
+		goto done;
+	p = ++forward;
+	if (strlen(p) == 0)
+		goto done;
+
+	/* filter */
+	if (p)
+		lu->filter = p;
+done:
+	free(url);
+	return (1);
+fail:
+	free(lu->buffer);
+	lu->buffer = NULL;
+	return (-1);
+}
+
+int
+aldap_search_url(struct aldap *ldap, char *url, int typesonly, int sizelimit,
+    int timelimit)
+{
+	struct aldap_url *lu;
+
+	if ((lu = calloc(1, sizeof(*lu))) == NULL)
+		return (-1);
+
+	if (aldap_parse_url(url, lu))
+		goto fail;
+
+	if (aldap_search(ldap, lu->dn, lu->scope, lu->filter, lu->attributes,
+	    typesonly, sizelimit, timelimit) == -1)
+		goto fail;
+
+	aldap_free_url(lu);
+	return (ldap->msgid);
+fail:
+	aldap_free_url(lu);
+	return (-1);
+}
+#endif /* 0 */
+
+/*
+ * internal functions
+ */
+
+char **
+aldap_get_stringset(struct ber_element *elm)
+{
+	struct ber_element *a;
+	int i;
+	char **ret;
+	char *s;
+
+	if (elm->be_type != BER_TYPE_OCTETSTRING)
+		return NULL;
+
+	for (a = elm, i = 1; i > 0 && a != NULL && a->be_type ==
+	    BER_TYPE_OCTETSTRING; a = a->be_next, i++)
+		;
+	if (i == 1)
+		return NULL;
+
+	if ((ret = calloc(i + 1, sizeof(char *))) == NULL)
+		return NULL;
+
+	for (a = elm, i = 0; a != NULL && a->be_type == BER_TYPE_OCTETSTRING;
+	    a = a->be_next, i++) {
+
+		ber_get_string(a, &s);
+		ret[i] = utoa(s);
+	}
+	ret[i + 1] = NULL;
+
+	return ret;
+}
+
+/*
+ * Base case for ldap_do_parse_search_filter
+ *
+ * returns:
+ *	struct ber_element *, ber_element tree
+ *	NULL, parse failed
+ */
+static struct ber_element *
+ldap_parse_search_filter(struct ber_element *ber, char *filter)
+{
+	struct ber_element *elm;
+	char *cp;
+
+	cp = filter;
+
+	if (cp == NULL || *cp == '\0') {
+		errno = EINVAL;
+		return (NULL);
+	}
+
+	if ((elm = ldap_do_parse_search_filter(ber, &cp)) == NULL)
+		return (NULL);
+
+	if (*cp != '\0') {
+		ber_free_elements(elm);
+		ber_link_elements(ber, NULL);
+		errno = EINVAL;
+		return (NULL);
+	}
+
+	return (elm);
+}
+
+/*
+ * Translate RFC4515 search filter string into ber_element tree
+ *
+ * returns:
+ *	struct ber_element *, ber_element tree
+ *	NULL, parse failed
+ *
+ * notes:
+ *	when cp is passed to a recursive invocation, it is updated
+ *	    to point one character beyond the filter that was passed
+ *	    i.e., cp jumps to "(filter)" upon return
+ *	                               ^
+ *	goto's used to discriminate error-handling based on error type
+ *	doesn't handle extended filters (yet)
+ *
+ */
+static struct ber_element *
+ldap_do_parse_search_filter(struct ber_element *prev, char **cpp)
+{
+	struct ber_element *elm, *root = NULL;
+	char *attr_desc, *attr_val, *parsed_val, *cp;
+	size_t len;
+	unsigned long type;
+
+	root = NULL;
+
+	/* cpp should pass in pointer to opening parenthesis of "(filter)" */
+	cp = *cpp;
+	if (*cp != '(')
+		goto syntaxfail;
+
+	switch (*++cp) {
+	case '&':		/* AND */
+	case '|':		/* OR */
+		if (*cp == '&')
+			type = LDAP_FILT_AND;
+		else
+			type = LDAP_FILT_OR;
+
+		if ((elm = ber_add_set(prev)) == NULL)
+			goto callfail;
+		root = elm;
+		ber_set_header(elm, BER_CLASS_CONTEXT, type);
+
+		if (*++cp != '(')		/* opening `(` of filter */
+			goto syntaxfail;
+
+		while (*cp == '(') {
+			if ((elm =
+			    ldap_do_parse_search_filter(elm, &cp)) == NULL)
+				goto bad;
+		}
+
+		if (*cp != ')')			/* trailing `)` of filter */
+			goto syntaxfail;
+		break;
+
+	case '!':		/* NOT */
+		if ((root = ber_add_sequence(prev)) == NULL)
+			goto callfail;
+		ber_set_header(root, BER_CLASS_CONTEXT, LDAP_FILT_NOT);
+
+		cp++;				/* now points to sub-filter */
+		if ((elm = ldap_do_parse_search_filter(root, &cp)) == NULL)
+			goto bad;
+
+		if (*cp != ')')			/* trailing `)` of filter */
+			goto syntaxfail;
+		break;
+
+	default:	/* SIMPLE || PRESENCE */
+		attr_desc = cp;
+
+		len = strcspn(cp, "()<>~=");
+		cp += len;
+		switch (*cp) {
+		case '~':
+			type = LDAP_FILT_APPR;
+			cp++;
+			break;
+		case '<':
+			type = LDAP_FILT_LE;
+			cp++;
+			break;
+		case '>':
+			type = LDAP_FILT_GE;
+			cp++;
+			break;
+		case '=':
+			type = LDAP_FILT_EQ;	/* assume EQ until disproven */
+			break;
+		case '(':
+		case ')':
+		default:
+			goto syntaxfail;
+		}
+		attr_val = ++cp;
+
+		/* presence filter */
+		if (strncmp(attr_val, "*)", 2) == 0) {
+			cp++;			/* point to trailing `)` */
+			if ((root =
+			    ber_add_nstring(prev, attr_desc, len)) == NULL)
+				goto bad;
+
+			ber_set_header(root, BER_CLASS_CONTEXT, LDAP_FILT_PRES);
+			break;
+		}
+
+		if ((root = ber_add_sequence(prev)) == NULL)
+			goto callfail;
+		ber_set_header(root, BER_CLASS_CONTEXT, type);
+
+		if ((elm = ber_add_nstring(root, attr_desc, len)) == NULL)
+			goto callfail;
+
+		len = strcspn(attr_val, "*)");
+		if (len == 0 && *cp != '*')
+			goto syntaxfail;
+		cp += len;
+		if (*cp == '\0')
+			goto syntaxfail;
+
+		if (*cp == '*') {	/* substring filter */
+			int initial;
+
+			cp = attr_val;
+
+			ber_set_header(root, BER_CLASS_CONTEXT, LDAP_FILT_SUBS);
+
+			if ((elm = ber_add_sequence(elm)) == NULL)
+				goto callfail;
+
+			for (initial = 1;; cp++, initial = 0) {
+				attr_val = cp;
+
+				len = strcspn(attr_val, "*)");
+				if (len == 0) {
+					if (*cp == ')')
+						break;
+					else
+						continue;
+				}
+				cp += len;
+				if (*cp == '\0')
+					goto syntaxfail;
+
+				if (initial)
+					type = LDAP_FILT_SUBS_INIT;
+				else if (*cp == ')')
+					type = LDAP_FILT_SUBS_FIN;
+				else
+					type = LDAP_FILT_SUBS_ANY;
+
+				if ((parsed_val = parseval(attr_val, len)) ==
+				    NULL)
+					goto callfail;
+				elm = ber_add_nstring(elm, parsed_val,
+				    strlen(parsed_val));
+				free(parsed_val);
+				if (elm == NULL)
+					goto callfail;
+				ber_set_header(elm, BER_CLASS_CONTEXT, type);
+				if (type == LDAP_FILT_SUBS_FIN)
+					break;
+			}
+			break;
+		}
+
+		if ((parsed_val = parseval(attr_val, len)) == NULL)
+			goto callfail;
+		elm = ber_add_nstring(elm, parsed_val, strlen(parsed_val));
+		free(parsed_val);
+		if (elm == NULL)
+			goto callfail;
+		break;
+	}
+
+	cp++;		/* now points one char beyond the trailing `)` */
+
+	*cpp = cp;
+	return (root);
+
+syntaxfail:		/* XXX -- error reporting */
+callfail:
+bad:
+	if (root != NULL)
+		ber_free_elements(root);
+	ber_link_elements(prev, NULL);
+	return (NULL);
+}
+
+#ifdef DEBUG
+/*
+ * Display a list of ber elements.
+ *
+ */
+void
+ldap_debug_elements(struct ber_element *root)
+{
+	static int	 indent = 0;
+	long long	 v;
+	int		 d;
+	char		*buf;
+	size_t		 len;
+	u_int		 i;
+	int		 constructed;
+	struct ber_oid	 o;
+
+	/* calculate lengths */
+	ber_calc_len(root);
+
+	switch (root->be_encoding) {
+	case BER_TYPE_SEQUENCE:
+	case BER_TYPE_SET:
+		constructed = root->be_encoding;
+		break;
+	default:
+		constructed = 0;
+		break;
+	}
+
+	fprintf(stderr, "%*slen %lu ", indent, "", root->be_len);
+	switch (root->be_class) {
+	case BER_CLASS_UNIVERSAL:
+		fprintf(stderr, "class: universal(%u) type: ", root->be_class);
+		switch (root->be_type) {
+		case BER_TYPE_EOC:
+			fprintf(stderr, "end-of-content");
+			break;
+		case BER_TYPE_BOOLEAN:
+			fprintf(stderr, "boolean");
+			break;
+		case BER_TYPE_INTEGER:
+			fprintf(stderr, "integer");
+			break;
+		case BER_TYPE_BITSTRING:
+			fprintf(stderr, "bit-string");
+			break;
+		case BER_TYPE_OCTETSTRING:
+			fprintf(stderr, "octet-string");
+			break;
+		case BER_TYPE_NULL:
+			fprintf(stderr, "null");
+			break;
+		case BER_TYPE_OBJECT:
+			fprintf(stderr, "object");
+			break;
+		case BER_TYPE_ENUMERATED:
+			fprintf(stderr, "enumerated");
+			break;
+		case BER_TYPE_SEQUENCE:
+			fprintf(stderr, "sequence");
+			break;
+		case BER_TYPE_SET:
+			fprintf(stderr, "set");
+			break;
+		}
+		break;
+	case BER_CLASS_APPLICATION:
+		fprintf(stderr, "class: application(%u) type: ",
+		    root->be_class);
+		switch (root->be_type) {
+		case LDAP_REQ_BIND:
+			fprintf(stderr, "bind");
+			break;
+		case LDAP_RES_BIND:
+			fprintf(stderr, "bind");
+			break;
+		case LDAP_REQ_UNBIND_30:
+			break;
+		case LDAP_REQ_SEARCH:
+			fprintf(stderr, "search");
+			break;
+		case LDAP_RES_SEARCH_ENTRY:
+			fprintf(stderr, "search_entry");
+			break;
+		case LDAP_RES_SEARCH_RESULT:
+			fprintf(stderr, "search_result");
+			break;
+		case LDAP_REQ_MODIFY:
+			fprintf(stderr, "modify");
+			break;
+		case LDAP_RES_MODIFY:
+			fprintf(stderr, "modify");
+			break;
+		case LDAP_REQ_ADD:
+			fprintf(stderr, "add");
+			break;
+		case LDAP_RES_ADD:
+			fprintf(stderr, "add");
+			break;
+		case LDAP_REQ_DELETE_30:
+			fprintf(stderr, "delete");
+			break;
+		case LDAP_RES_DELETE:
+			fprintf(stderr, "delete");
+			break;
+		case LDAP_REQ_MODRDN:
+			fprintf(stderr, "modrdn");
+			break;
+		case LDAP_RES_MODRDN:
+			fprintf(stderr, "modrdn");
+			break;
+		case LDAP_REQ_COMPARE:
+			fprintf(stderr, "compare");
+			break;
+		case LDAP_RES_COMPARE:
+			fprintf(stderr, "compare");
+			break;
+		case LDAP_REQ_ABANDON_30:
+			fprintf(stderr, "abandon");
+			break;
+		}
+		break;
+	case BER_CLASS_PRIVATE:
+		fprintf(stderr, "class: private(%u) type: ", root->be_class);
+		fprintf(stderr, "encoding (%lu) type: ", root->be_encoding);
+		break;
+	case BER_CLASS_CONTEXT:
+		/* XXX: this is not correct */
+		fprintf(stderr, "class: context(%u) type: ", root->be_class);
+		switch(root->be_type) {
+		case LDAP_AUTH_SIMPLE:
+			fprintf(stderr, "auth simple");
+			break;
+		}
+		break;
+	default:
+		fprintf(stderr, "class: <INVALID>(%u) type: ", root->be_class);
+		break;
+	}
+	fprintf(stderr, "(%lu) encoding %lu ",
+	    root->be_type, root->be_encoding);
+
+	if (constructed)
+		root->be_encoding = constructed;
+
+	switch (root->be_encoding) {
+	case BER_TYPE_BOOLEAN:
+		if (ber_get_boolean(root, &d) == -1) {
+			fprintf(stderr, "<INVALID>\n");
+			break;
+		}
+		fprintf(stderr, "%s(%d)\n", d ? "true" : "false", d);
+		break;
+	case BER_TYPE_INTEGER:
+		if (ber_get_integer(root, &v) == -1) {
+			fprintf(stderr, "<INVALID>\n");
+			break;
+		}
+		fprintf(stderr, "value %lld\n", v);
+		break;
+	case BER_TYPE_ENUMERATED:
+		if (ber_get_enumerated(root, &v) == -1) {
+			fprintf(stderr, "<INVALID>\n");
+			break;
+		}
+		fprintf(stderr, "value %lld\n", v);
+		break;
+	case BER_TYPE_BITSTRING:
+		if (ber_get_bitstring(root, (void *)&buf, &len) == -1) {
+			fprintf(stderr, "<INVALID>\n");
+			break;
+		}
+		fprintf(stderr, "hexdump ");
+		for (i = 0; i < len; i++)
+			fprintf(stderr, "%02x", buf[i]);
+		fprintf(stderr, "\n");
+		break;
+	case BER_TYPE_OBJECT:
+		if (ber_get_oid(root, &o) == -1) {
+			fprintf(stderr, "<INVALID>\n");
+			break;
+		}
+		fprintf(stderr, "\n");
+		break;
+	case BER_TYPE_OCTETSTRING:
+		if (ber_get_nstring(root, (void *)&buf, &len) == -1) {
+			fprintf(stderr, "<INVALID>\n");
+			break;
+		}
+		fprintf(stderr, "string \"%.*s\"\n",  len, buf);
+		break;
+	case BER_TYPE_NULL:	/* no payload */
+	case BER_TYPE_EOC:
+	case BER_TYPE_SEQUENCE:
+	case BER_TYPE_SET:
+	default:
+		fprintf(stderr, "\n");
+		break;
+	}
+
+	if (constructed && root->be_sub) {
+		indent += 2;
+		ldap_debug_elements(root->be_sub);
+		indent -= 2;
+	}
+	if (root->be_next)
+		ldap_debug_elements(root->be_next);
+}
+#endif
+
+/*
+ * Strip UTF-8 down to ASCII without validation.
+ * notes:
+ *	non-ASCII characters are displayed as '?'
+ *	the argument u should be a NULL terminated sequence of UTF-8 bytes.
+ */
+char *
+utoa(char *u)
+{
+	int	 len, i, j;
+	char	*str;
+
+	/* calculate the length to allocate */
+	for (len = 0, i = 0; u[i] != '\0'; i++)
+		if (!isu8cont(u[i]))
+			len++;
+
+	if ((str = calloc(len + 1, sizeof(char))) == NULL)
+		return NULL;
+
+	/* copy the ASCII characters to the newly allocated string */
+	for (i = 0, j = 0; u[i] != '\0'; i++)
+		if (!isu8cont(u[i]))
+			str[j++] = isascii((unsigned char)u[i]) ? u[i] : '?';
+
+	return str;
+}
+
+static int
+isu8cont(unsigned char c)
+{
+	return (c & (0x80 | 0x40)) == 0x80;
+}
+
+/*
+ * Parse a LDAP value
+ * notes:
+ *	the argument p should be a NUL-terminated sequence of ASCII bytes
+ */
+char *
+parseval(char *p, size_t len)
+{
+	char	 hex[3];
+	char	*buffer;
+	size_t	 i, j;
+
+	if ((buffer = calloc(1, len + 1)) == NULL)
+		return NULL;
+
+	for (i = j = 0; j < len; i++) {
+		if (p[j] == '\\') {
+			strlcpy(hex, p + j + 1, sizeof(hex));
+			buffer[i] = (char)strtoumax(hex, NULL, 16);
+			j += 3;
+		} else {
+			buffer[i] = p[j];
+			j++;
+		}
+	}
+
+	return buffer;
+}
+
+int
+aldap_get_errno(struct aldap *a, const char **estr)
+{
+	switch (a->err) {
+	case ALDAP_ERR_SUCCESS:
+		*estr = "success";
+		break;
+	case ALDAP_ERR_PARSER_ERROR:
+		*estr = "parser failed";
+		break;
+	case ALDAP_ERR_INVALID_FILTER:
+		*estr = "invalid filter";
+		break;
+	case ALDAP_ERR_OPERATION_FAILED:
+		*estr = "operation failed";
+		break;
+	case ALDAP_ERR_TLS_ERROR:
+		*estr = tls_error(a->tls);
+		break;
+	default:
+		*estr = "unknown";
+		break;
+	}
+	return (a->err);
+}
Index: usr.sbin/ldapctl/aldap.h
===================================================================
RCS file: usr.sbin/ldapctl/aldap.h
diff -N usr.sbin/ldapctl/aldap.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ usr.sbin/ldapctl/aldap.h	15 May 2018 12:58:18 -0000
@@ -0,0 +1,237 @@
+/*	$OpenBSD: aldap.h,v 1.10 2017/05/30 09:33:31 jmatthew Exp $ */
+
+/*
+ * Copyright (c) 2008 Alexander Schrijver <aschrijver@openbsd.org>
+ * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <stdio.h>
+
+#include <tls.h>
+
+#include "ber.h"
+
+#define LDAP_URL 		"ldap://"
+#define LDAP_PORT 		389
+#define LDAPS_PORT 		636
+#define LDAP_PAGED_OID		"1.2.840.113556.1.4.319"
+#define LDAP_STARTTLS_OID	"1.3.6.1.4.1.1466.20037"
+
+struct aldap {
+#define ALDAP_ERR_SUCCESS		0
+#define ALDAP_ERR_PARSER_ERROR		1
+#define ALDAP_ERR_INVALID_FILTER	2
+#define ALDAP_ERR_OPERATION_FAILED	3
+#define ALDAP_ERR_TLS_ERROR		4
+	u_int8_t	err;
+	int		msgid;
+	struct ber	ber;
+
+	int		fd;
+	struct tls	*tls;
+
+	struct evbuffer *buf;
+};
+
+struct aldap_page_control {
+	int size;
+	char *cookie;
+	unsigned int cookie_len;
+};
+
+struct aldap_message {
+	int msgid;
+	int message_type;
+
+	struct ber_element	*msg;
+
+	struct ber_element	*header;
+	struct ber_element	*protocol_op;
+
+	struct ber_element	*dn;
+
+	union {
+		struct {
+			long long		 rescode;
+			struct ber_element	*diagmsg;
+		}			 res;
+		struct {
+			struct ber_element	*iter;
+			struct ber_element	*attrs;
+		}			 search;
+	} body;
+	struct ber_element	*references;
+	struct aldap_page_control *page; 
+};
+
+enum aldap_protocol {
+	LDAP,
+	LDAPS
+};
+
+struct aldap_url {
+	int		 protocol;
+	char		*host;
+	in_port_t	 port;
+	char		*dn;
+#define MAXATTR 1024
+	char		*attributes[MAXATTR];
+	int		 scope;
+	char		*filter;
+	char		*buffer;
+};
+
+enum protocol_op {
+	LDAP_REQ_BIND		= 0,
+	LDAP_RES_BIND		= 1,
+	LDAP_REQ_UNBIND_30	= 2,
+	LDAP_REQ_SEARCH		= 3,
+	LDAP_RES_SEARCH_ENTRY	= 4,
+	LDAP_RES_SEARCH_RESULT	= 5,
+	LDAP_REQ_MODIFY		= 6,
+	LDAP_RES_MODIFY		= 7,
+	LDAP_REQ_ADD		= 8,
+	LDAP_RES_ADD		= 9,
+	LDAP_REQ_DELETE_30	= 10,
+	LDAP_RES_DELETE		= 11,
+	LDAP_REQ_MODRDN		= 12,
+	LDAP_RES_MODRDN		= 13,
+	LDAP_REQ_COMPARE	= 14,
+	LDAP_RES_COMPARE	= 15,
+	LDAP_REQ_ABANDON_30	= 16,
+
+	LDAP_RES_SEARCH_REFERENCE = 19,
+
+	LDAP_REQ_EXTENDED	= 23,
+	LDAP_RES_EXTENDED	= 24
+};
+
+enum deref_aliases {
+	LDAP_DEREF_NEVER	= 0,
+	LDAP_DEREF_SEARCHING	= 1,
+	LDAP_DEREF_FINDING	= 2,
+	LDAP_DEREF_ALWAYS	= 3,
+};
+
+enum authentication_choice {
+	LDAP_AUTH_SIMPLE	= 0,
+};
+
+enum scope {
+	LDAP_SCOPE_BASE		= 0,
+	LDAP_SCOPE_ONELEVEL	= 1,
+	LDAP_SCOPE_SUBTREE	= 2,
+};
+
+enum result_code {
+	LDAP_SUCCESS				= 0,
+	LDAP_OPERATIONS_ERROR			= 1,
+	LDAP_PROTOCOL_ERROR			= 2,
+	LDAP_TIMELIMIT_EXCEEDED			= 3,
+	LDAP_SIZELIMIT_EXCEEDED			= 4,
+	LDAP_COMPARE_FALSE			= 5,
+	LDAP_COMPARE_TRUE			= 6,
+	LDAP_STRONG_AUTH_NOT_SUPPORTED		= 7,
+	LDAP_STRONG_AUTH_REQUIRED		= 8,
+
+	LDAP_REFERRAL				= 10,
+	LDAP_ADMINLIMIT_EXCEEDED		= 11,
+	LDAP_UNAVAILABLE_CRITICAL_EXTENSION	= 12,
+	LDAP_CONFIDENTIALITY_REQUIRED		= 13,
+	LDAP_SASL_BIND_IN_PROGRESS		= 14,
+	LDAP_NO_SUCH_ATTRIBUTE			= 16,
+	LDAP_UNDEFINED_TYPE			= 17,
+	LDAP_INAPPROPRIATE_MATCHING		= 18,
+	LDAP_CONSTRAINT_VIOLATION		= 19,
+	LDAP_TYPE_OR_VALUE_EXISTS		= 20,
+	LDAP_INVALID_SYNTAX			= 21,
+
+	LDAP_NO_SUCH_OBJECT			= 32,
+	LDAP_ALIAS_PROBLEM			= 33,
+	LDAP_INVALID_DN_SYNTAX			= 34,
+
+	LDAP_ALIAS_DEREF_PROBLEM		= 36,
+
+	LDAP_INAPPROPRIATE_AUTH			= 48,
+	LDAP_INVALID_CREDENTIALS		= 49,
+	LDAP_INSUFFICIENT_ACCESS		= 50,
+	LDAP_BUSY				= 51,
+	LDAP_UNAVAILABLE			= 52,
+	LDAP_UNWILLING_TO_PERFORM		= 53,
+	LDAP_LOOP_DETECT			= 54,
+
+	LDAP_NAMING_VIOLATION			= 64,
+	LDAP_OBJECT_CLASS_VIOLATION		= 65,
+	LDAP_NOT_ALLOWED_ON_NONLEAF		= 66,
+	LDAP_NOT_ALLOWED_ON_RDN			= 67,
+	LDAP_ALREADY_EXISTS			= 68,
+	LDAP_NO_OBJECT_CLASS_MODS		= 69,
+
+	LDAP_AFFECTS_MULTIPLE_DSAS		= 71,
+
+	LDAP_OTHER				= 80,
+};
+
+enum filter {
+	LDAP_FILT_AND		= 0,
+	LDAP_FILT_OR		= 1,
+	LDAP_FILT_NOT		= 2,
+	LDAP_FILT_EQ		= 3,
+	LDAP_FILT_SUBS		= 4,
+	LDAP_FILT_GE		= 5,
+	LDAP_FILT_LE		= 6,
+	LDAP_FILT_PRES		= 7,
+	LDAP_FILT_APPR		= 8,
+};
+
+enum subfilter {
+	LDAP_FILT_SUBS_INIT	= 0,
+	LDAP_FILT_SUBS_ANY	= 1,
+	LDAP_FILT_SUBS_FIN	= 2,
+};
+
+struct aldap		*aldap_init(int);
+int			 aldap_tls(struct aldap *, struct tls_config *,
+			    const char *);
+int			 aldap_close(struct aldap *);
+struct aldap_message	*aldap_parse(struct aldap *);
+void			 aldap_freemsg(struct aldap_message *);
+
+int	 		 aldap_req_starttls(struct aldap *);
+
+int	 aldap_bind(struct aldap *, char *, char *);
+int	 aldap_unbind(struct aldap *);
+int	 aldap_search(struct aldap *, char *, enum scope, char *, char **, int, int, int, struct aldap_page_control *);
+int	 aldap_get_errno(struct aldap *, const char **);
+
+int	 aldap_get_resultcode(struct aldap_message *);
+char	*aldap_get_dn(struct aldap_message *);
+char	*aldap_get_diagmsg(struct aldap_message *);
+char	**aldap_get_references(struct aldap_message *);
+void	 aldap_free_references(char **values);
+#if 0
+int	 aldap_parse_url(char *, struct aldap_url *);
+void	 aldap_free_url(struct aldap_url *);
+int	 aldap_search_url(struct aldap *, char *, int, int, int);
+#endif
+
+int	 aldap_count_attrs(struct aldap_message *);
+int	 aldap_match_attr(struct aldap_message *, char *, char ***);
+int	 aldap_first_attr(struct aldap_message *, char **, char ***);
+int	 aldap_next_attr(struct aldap_message *, char **, char ***);
+int	 aldap_free_attr(char **);
+
+struct aldap_page_control *aldap_parse_page_control(struct ber_element *, size_t len);
+void	 aldap_freepage(struct aldap_page_control *);
Index: usr.sbin/ldapctl/ldapclient.c
===================================================================
RCS file: usr.sbin/ldapctl/ldapclient.c
diff -N usr.sbin/ldapctl/ldapclient.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ usr.sbin/ldapctl/ldapclient.c	15 May 2018 12:58:18 -0000
@@ -0,0 +1,567 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) 2018 Reyk Floeter <reyk@openbsd.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/param.h>
+#include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/tree.h>
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <netdb.h>
+#include <errno.h>
+#include <err.h>
+#include <signal.h>
+#include <event.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <readpassphrase.h>
+#include <vis.h>
+#include <resolv.h>
+
+#include "aldap.h"
+#include "log.h"
+
+#define F_STARTTLS	0x01
+#define F_TLS		0x02
+#define F_NEEDAUTH	0x04
+#define F_LDIF		0x08
+
+#define CAPATH		"/etc/ssl/cert.pem"
+#define LDAPPORT	"389"
+#define LDAPFILTER	"(objectClass=*)"
+#define LDIF_LINELENGTH	79
+
+struct ldapc {
+	struct aldap	*ldap_al;
+	char		*ldap_host;
+	char		*ldap_port;
+	char		*ldap_capath;
+	char		*ldap_binddn;
+	char		*ldap_secret;
+	unsigned int	 ldap_flags;
+};
+
+struct ldapc_search {
+	char		*ls_basedn;
+	char		*ls_filter;
+	enum scope	 ls_scope;
+	char		**ls_attr;
+};
+
+__dead void	 ldapc_usage(void);
+int		 ldapc_main(int, char *[]);
+int		 ldapc_connect(struct ldapc *);
+int		 ldapc_search(struct ldapc *, struct ldapc_search *);
+int		 ldapc_printattr(struct ldapc *, const char *, const char *);
+void		 ldapc_disconnect(struct ldapc *);
+const char	*ldapc_resultcode(enum result_code);
+
+__dead void
+ldapc_usage(void)
+{
+	extern char	*__progname;
+
+	fprintf(stderr, "usage: %s search "
+	    "[-LvxZ] [-c capath] [-p port] [-b basedn]\n"
+	    "%*s [-D binddn] [-w secret|-W] [-s scope] -h host [filter]\n",
+	    __progname, (int)(strlen(__progname) +
+	    strlen("search usage: ")), "");
+	exit(1);
+}
+
+int
+ldapc_main(int argc, char *argv[])
+{
+	char			 passbuf[256];
+	struct ldapc		 ldap;
+	struct ldapc_search	 ls;
+	int			 ch;
+	int			 verbose = 1;
+
+	if (pledge("stdio inet tty rpath dns", NULL) == -1)
+		err(1, "pledge");
+
+	log_init(verbose, 0);
+
+	memset(&ldap, 0, sizeof(ldap));
+	memset(&ls, 0, sizeof(ls));
+
+	ldap.ldap_port = LDAPPORT;
+	ldap.ldap_capath = CAPATH;
+
+	ls.ls_basedn = "";
+	ls.ls_scope = LDAP_SCOPE_SUBTREE;
+	ls.ls_filter = LDAPFILTER;
+
+	while ((ch = getopt(argc, argv, "b:c:D:h:Lp:s:vWw:xZ")) != -1) {
+		switch (ch) {
+		case 'b':
+			ls.ls_basedn = optarg;
+			break;
+		case 'c':
+			ldap.ldap_capath = optarg;
+			break;
+		case 'D':
+			ldap.ldap_binddn = optarg;
+			ldap.ldap_flags |= F_NEEDAUTH;
+			break;
+		case 'h':
+			ldap.ldap_host = optarg;
+			break;
+		case 'L':
+			ldap.ldap_flags |= F_LDIF;
+			break;
+		case 'p':
+			ldap.ldap_port = optarg;
+			break;
+		case 's':
+			if (strcasecmp("base", optarg) == 0)
+				ls.ls_scope = LDAP_SCOPE_BASE;
+			else if (strcasecmp("one", optarg) == 0)
+				ls.ls_scope = LDAP_SCOPE_ONELEVEL;
+			else if (strcasecmp("sub", optarg) == 0)
+				ls.ls_scope = LDAP_SCOPE_SUBTREE;
+			else
+				errx(1, "invalid scope: %s", optarg);
+			break;
+		case 'v':
+			verbose++;
+			break;
+		case 'w':
+			ldap.ldap_secret = optarg;
+			ldap.ldap_flags |= F_NEEDAUTH;
+			break;
+		case 'W':
+			ldap.ldap_flags |= F_NEEDAUTH;
+			break;
+		case 'x':
+			/* provided for compatibility */
+			break;
+		case 'Z':
+			ldap.ldap_flags |= F_STARTTLS;
+			break;
+		default:
+			ldapc_usage();
+		}
+	}
+	argc -= optind;
+	argv += optind;
+
+	log_setverbose(verbose);
+
+	if (ldap.ldap_host == NULL || ldap.ldap_port == NULL) {
+		log_warnx("missing arguments");
+		ldapc_usage();
+	}
+
+	if (ldap.ldap_flags & F_NEEDAUTH) {
+		if (ldap.ldap_secret == NULL) {
+			if (readpassphrase("Password: ",
+			    passbuf, sizeof(passbuf), RPP_REQUIRE_TTY) == NULL)
+				errx(1, "failed to read LDAP password");
+			ldap.ldap_secret = passbuf;
+		}
+		if (ldap.ldap_binddn == NULL) {
+			log_warnx("missing -D binddn");
+			ldapc_usage();
+		}
+	}
+
+	if (pledge("stdio inet rpath dns", NULL) == -1)
+		err(1, "pledge");
+
+	/* optional search filter */
+	if (argc && strchr(argv[0], '=') != NULL) {
+		ls.ls_filter = argv[0];
+		argc--;
+		argv++;
+	}
+	/* search attributes */
+	if (argc)
+		ls.ls_attr = argv;
+
+	if (ldapc_connect(&ldap) == -1)
+		errx(1, "LDAP connection failed");
+
+	if (pledge("stdio inet", NULL) == -1)
+		err(1, "pledge");
+
+	if (ldapc_search(&ldap, &ls) == -1)
+		errx(1, "LDAP search failed");
+
+	ldapc_disconnect(&ldap);
+
+	return (0);
+}
+
+int
+ldapc_search(struct ldapc *ldap, struct ldapc_search *ls)
+{
+	struct aldap_page_control	*pg = NULL;
+	struct aldap_message		*m;
+	const char			*errstr;
+	const char			*searchdn, *dn = NULL;
+	char				*outkey;
+	char				**outvalues;
+	int				 ret, i, code, fail = 0;
+
+	do {
+		if (aldap_search(ldap->ldap_al, ls->ls_basedn, ls->ls_scope,
+		    ls->ls_filter, ls->ls_attr, 0, 0, 0, pg) == -1) {
+			aldap_get_errno(ldap->ldap_al, &errstr);
+			log_warnx("LDAP search failed: %s", errstr);
+			return (-1);
+		}
+
+		if (pg != NULL) {
+			aldap_freepage(pg);
+			pg = NULL;
+		}
+
+		while ((m = aldap_parse(ldap->ldap_al)) != NULL) {
+			if (ldap->ldap_al->msgid != m->msgid) {
+				goto fail;
+			}
+
+			if ((code = aldap_get_resultcode(m)) != LDAP_SUCCESS) {
+				log_warnx("LDAP search failed: %s(%d)",
+				    ldapc_resultcode(code), code);
+				break;
+			}
+
+			if (m->message_type == LDAP_RES_SEARCH_RESULT) {
+				if (m->page != NULL && m->page->cookie_len != 0)
+					pg = m->page;
+				else
+					pg = NULL;
+
+				aldap_freemsg(m);
+				break;
+			}
+
+			if (m->message_type != LDAP_RES_SEARCH_ENTRY) {
+				goto fail;
+			}
+
+			if (aldap_count_attrs(m) < 1) {
+				aldap_freemsg(m);
+				continue;
+			}
+
+			if ((searchdn = aldap_get_dn(m)) == NULL)
+				goto fail;
+
+			if (dn != NULL)
+				printf("\n");
+			else
+				dn = ls->ls_basedn;
+			if (strcmp(dn, searchdn) != 0)
+				printf("dn: %s\n", searchdn);
+
+			for (ret = aldap_first_attr(m, &outkey, &outvalues);
+			    ret != -1;
+			    ret = aldap_next_attr(m, &outkey, &outvalues)) {
+				for (i = 0; outvalues != NULL &&
+				    outvalues[i] != NULL; i++) {
+					if (ldapc_printattr(ldap, outkey,
+					    outvalues[i]) == -1) {
+						fail = 1;
+						break;
+					}
+				}
+			}
+			free(outkey);
+			aldap_free_attr(outvalues);
+
+			aldap_freemsg(m);
+		}
+	} while (pg != NULL && fail == 0);
+
+	if (fail)
+		return (-1);
+	return (0);
+ fail:
+	ldapc_disconnect(ldap);
+	return (-1);
+}
+
+int
+ldapc_printattr(struct ldapc *ldap, const char *key, const char *value)
+{
+	char		*p = NULL, *out;
+	const char	*cp;
+	int		 encode;
+	size_t		 inlen, outlen, left;
+
+	if (ldap->ldap_flags & F_LDIF) {
+		/* OpenLDAP encodes the userPassword by default */
+		if (strcasecmp("userPassword", key) == 0)
+			encode = 1;
+		else
+			encode = 0;
+
+		/*
+		 * The LDIF format a set of characters that can be included
+		 * in SAFE-STRINGs. String value that do not match the
+		 * criteria must be encoded as Base64.
+		 */
+		for (cp = value; encode == 0 &&*cp != '\0'; cp++) {
+			/* !SAFE-CHAR %x01-09 / %x0B-0C / %x0E-7F */
+			if (*cp > 127 |
+			    *cp == '\0' ||
+			    *cp == '\n' ||
+			    *cp == '\r')
+				encode = 1;
+		}
+
+		if (!encode) {
+			if (asprintf(&p, "%s: %s", key, value) == -1) {
+				log_warnx("asprintf");
+				return (-1);
+			}
+		} else {
+			inlen = strlen(value);
+			outlen = inlen * 2 + 1;
+
+			if ((out = calloc(1, outlen)) == NULL ||
+			    b64_ntop(value, inlen, out, outlen) == -1) {
+				log_warnx("Base64 encoding failed");
+				free(p);
+				return (-1);
+			}
+
+			/* Base64 is indicated with a double-colon */
+			if (asprintf(&p, "%s: %s", key, out) == -1) {
+				log_warnx("asprintf");
+				free(out);
+				return (-1);
+			}
+			free(out);
+		}
+
+		/* Wrap lines */
+		for (outlen = 0, inlen = strlen(p);
+		    outlen < inlen;
+		    outlen += LDIF_LINELENGTH) {
+			if (outlen)
+				putchar(' ');
+			/* max. line length - newline - optional indent */
+			left = MIN(inlen - outlen, outlen ?
+			    LDIF_LINELENGTH - 2 :
+			    LDIF_LINELENGTH - 1);
+			fwrite(p + outlen, left, 1, stdout);
+			putchar('\n');
+		}
+	} else {
+		/*
+		 * Use vis(1) instead of base64 encoding of non-printable
+		 * values.  This is much nicer as it always prdocues a
+		 * human-readable visual output.  This can safely be done
+		 * on all values no matter if they include non-printable
+		 * characters.
+		 */
+		if (stravis(&p, value, VIS_SAFE|VIS_NL) == -1) {
+			log_warn("visual encoding failed");
+			return (-1);
+		}
+
+		printf("%s: %s\n", key, p);
+	}
+
+	free(p);
+	return (0);
+}
+
+int
+ldapc_connect(struct ldapc *ldap)
+{
+	struct addrinfo		 ai, *res, *res0;
+	int			 ret, saved_errno, fd = -1, code = -1;
+	struct aldap_message	*m;
+	const char		*errstr;
+	struct tls_config	*tls_config;
+
+	memset(&ai, 0, sizeof(ai));
+	ai.ai_family = AF_UNSPEC;
+	ai.ai_socktype = SOCK_STREAM;
+	ai.ai_protocol = IPPROTO_TCP;
+	if ((ret = getaddrinfo(ldap->ldap_host, ldap->ldap_port,
+	    &ai, &res0)) != 0) {
+		log_warnx("%s", gai_strerror(ret));
+		return (-1);
+	}
+	for (res = res0; res; res = res->ai_next, fd = -1) {
+		if ((fd = socket(res->ai_family, res->ai_socktype,
+		    res->ai_protocol)) == -1)
+			continue;
+
+		if (connect(fd, res->ai_addr, res->ai_addrlen) >= 0)
+			break;
+
+		saved_errno = errno;
+		close(fd);
+		errno = saved_errno;
+	}
+	if (fd == -1)
+		return (-1);
+	freeaddrinfo(res0);
+
+	if ((ldap->ldap_al = aldap_init(fd)) == NULL) {
+		warn("LDAP init failed");
+		close(fd);
+		return (-1);
+	}
+
+	if (ldap->ldap_flags & F_STARTTLS) {
+		log_debug("%s: requesting STARTTLS", __func__);
+		if (aldap_req_starttls(ldap->ldap_al) == -1) {
+			log_warnx("failed to request STARTTLS");
+			goto fail;
+		}
+
+		if ((m = aldap_parse(ldap->ldap_al)) == NULL) {
+			log_warnx("failed to parse STARTTLS response");
+			goto fail;
+		}
+
+		if (ldap->ldap_al->msgid != m->msgid ||
+		    (code = aldap_get_resultcode(m)) != LDAP_SUCCESS) {
+			log_warnx("STARTTLS failed: %s(%d)",
+			    ldapc_resultcode(code), code);
+			aldap_freemsg(m);
+			goto fail;
+		}
+		aldap_freemsg(m);
+	}
+
+	if (ldap->ldap_flags & (F_STARTTLS | F_TLS)) {
+		log_debug("%s: starting TLS", __func__);
+
+		if ((tls_config = tls_config_new()) == NULL) {
+			log_warnx("TLS config failed");
+			goto fail;
+		}
+
+		if (tls_config_set_ca_file(tls_config,
+		    ldap->ldap_capath) == -1) {
+			log_warnx("unable to set CA %s", ldap->ldap_capath);
+			goto fail;
+		}
+
+		if (aldap_tls(ldap->ldap_al, tls_config, ldap->ldap_host) < 0) {
+			aldap_get_errno(ldap->ldap_al, &errstr);
+			log_warnx("TLS failed: %s", errstr);
+			goto fail;
+		}
+	}
+
+	if (ldap->ldap_flags & F_NEEDAUTH) {
+		log_debug("%s: bind request", __func__);
+		if (aldap_bind(ldap->ldap_al, ldap->ldap_binddn,
+		    ldap->ldap_secret) == -1) {
+			log_warnx("bind request failed");
+			goto fail;
+		}
+
+		if ((m = aldap_parse(ldap->ldap_al)) == NULL) {
+			log_warnx("failed to parse bind response");
+			goto fail;
+		}
+
+		if (ldap->ldap_al->msgid != m->msgid ||
+		    (code = aldap_get_resultcode(m)) != LDAP_SUCCESS) {
+			log_warnx("bind failed: %s(%d)",
+			    ldapc_resultcode(code), code);
+			aldap_freemsg(m);
+			goto fail;
+		}
+		aldap_freemsg(m);
+	}
+
+	log_debug("%s: connected", __func__);
+
+	return (0);
+ fail:
+	ldapc_disconnect(ldap);
+	return (-1);
+}
+
+void
+ldapc_disconnect(struct ldapc *ldap)
+{
+	if (ldap->ldap_al == NULL)
+		return;
+	aldap_close(ldap->ldap_al);
+	ldap->ldap_al = NULL;
+}
+
+const char *
+ldapc_resultcode(enum result_code code)
+{
+#define CODE(_X)	case _X:return (#_X)
+	switch (code) {
+	CODE(LDAP_SUCCESS);
+	CODE(LDAP_OPERATIONS_ERROR);
+	CODE(LDAP_PROTOCOL_ERROR);
+	CODE(LDAP_TIMELIMIT_EXCEEDED);
+	CODE(LDAP_SIZELIMIT_EXCEEDED);
+	CODE(LDAP_COMPARE_FALSE);
+	CODE(LDAP_COMPARE_TRUE);
+	CODE(LDAP_STRONG_AUTH_NOT_SUPPORTED);
+	CODE(LDAP_STRONG_AUTH_REQUIRED);
+	CODE(LDAP_REFERRAL);
+	CODE(LDAP_ADMINLIMIT_EXCEEDED);
+	CODE(LDAP_UNAVAILABLE_CRITICAL_EXTENSION);
+	CODE(LDAP_CONFIDENTIALITY_REQUIRED);
+	CODE(LDAP_SASL_BIND_IN_PROGRESS);
+	CODE(LDAP_NO_SUCH_ATTRIBUTE);
+	CODE(LDAP_UNDEFINED_TYPE);
+	CODE(LDAP_INAPPROPRIATE_MATCHING);
+	CODE(LDAP_CONSTRAINT_VIOLATION);
+	CODE(LDAP_TYPE_OR_VALUE_EXISTS);
+	CODE(LDAP_INVALID_SYNTAX);
+	CODE(LDAP_NO_SUCH_OBJECT);
+	CODE(LDAP_ALIAS_PROBLEM);
+	CODE(LDAP_INVALID_DN_SYNTAX);
+	CODE(LDAP_ALIAS_DEREF_PROBLEM);
+	CODE(LDAP_INAPPROPRIATE_AUTH);
+	CODE(LDAP_INVALID_CREDENTIALS);
+	CODE(LDAP_INSUFFICIENT_ACCESS);
+	CODE(LDAP_BUSY);
+	CODE(LDAP_UNAVAILABLE);
+	CODE(LDAP_UNWILLING_TO_PERFORM);
+	CODE(LDAP_LOOP_DETECT);
+	CODE(LDAP_NAMING_VIOLATION);
+	CODE(LDAP_OBJECT_CLASS_VIOLATION);
+	CODE(LDAP_NOT_ALLOWED_ON_NONLEAF);
+	CODE(LDAP_NOT_ALLOWED_ON_RDN);
+	CODE(LDAP_ALREADY_EXISTS);
+	CODE(LDAP_NO_OBJECT_CLASS_MODS);
+	CODE(LDAP_AFFECTS_MULTIPLE_DSAS);
+	CODE(LDAP_OTHER);
+	default:
+		return ("UNKNOWN_ERROR");
+	}
+};
Index: usr.sbin/ldapctl/ldapctl.8
===================================================================
RCS file: /cvs/src/usr.sbin/ldapctl/ldapctl.8,v
retrieving revision 1.6
diff -u -p -u -p -r1.6 ldapctl.8
--- usr.sbin/ldapctl/ldapctl.8	2 Feb 2016 17:39:02 -0000	1.6
+++ usr.sbin/ldapctl/ldapctl.8	15 May 2018 12:58:19 -0000
@@ -81,7 +81,110 @@ Read requests are handled without disrup
 Re-index all databases.
 .Xr ldapd 8
 does not have to be running.
+.It Cm search
+Run the LDAP search client, see
+.Sx LDAP SEARCH
+below.
 .El
+.Sh LDAP SEARCH
+The search command is a simple LDAP client.
+It queries an LDAP server to perform a directory search and outputs
+the results in the LDAP Data Interchange Format (LDIF).
+.Pp
+The optional
+.Ar filter
+argument specifies the LDAP filter for the directory search.
+The default is
+.Ar (objectClass=*)
+and the format must comply to the
+.Dq String Representation of Search Filters
+as described in RFC 4515.
+If one or more
+.Ar attribute
+options are specified,
+.Nm
+restricts the output to the specified attributes.
+.Pp
+The options are as follows:
+.Bl -tag -width Ds
+.It Fl b Ar basedn
+Use the specified distinguished name (dn) as the starting point for
+the directory search.
+.It Fl c Ar CAfile
+When TLS is enabled, load the CA bundle for certificate verification
+from the specified file.
+The default is
+.Pa /etc/ssl/cert.pem .
+If the LDAP server uses a self-signed certificate,
+use a file that contains the server certificate in PEM format, e.g.
+.Pa /etc/ssl/ldapserver.example.com.crt .
+.It Fl D Ar binddn
+Use the specified distinguished name to bind to the directory.
+.It Fl h Ar host
+The hostname of the LDAP server.
+.It Fl L
+Output the directory search result in a standards-compliant version of
+the LDAP Data Interchange Format (LDIF).
+This encodes attribute values that include non-printable or UTF-8
+characters in the Base64 format and wraps lines at a 79-character limit.
+If this option is not specified,
+.Nm
+encodes
+.Dq unsafe
+characters and newlines in a visual format using
+.Xr vis 3
+instead.
+.It Fl p Ar port
+The port of the LDAP server.
+The default is
+.Ar 389 .
+.It Fl s Ar scope
+Specify the
+.Ar scope
+to be either
+.Ic base ,
+.Ic one ,
+or
+.Ic sub .
+The default is
+.Ic sub
+for subtree searches.
+.It Fl v
+Product more verbose output.
+.It Fl W
+Prompt for the bind secret with echo turned off.
+.It Fl w Ar secret
+Specify the bind secret on the command line.
+.It Fl x
+Use simple authentication.
+This is the default as
+.Nm
+does not support SASL authentication.
+.It Fl Z
+Enable TLS using the StartTLS operation.
+.El
+.Sh EXAMPLES
+The following script can be used with the
+.Ar AuthorizedKeysCommand
+option of
+.Xr sshd 8 :
+.Bd -literal -offset indent
+#!/bin/sh
+ldapctl search -D cn=Reader,dc=example,dc=com -w mypass123 \e
+	-b ou=People,dc=example,dc=com \e
+	-h ldapserver -c /etc/ssl/ldapserver.crt -Z \e
+	"(&(objectClass=bsdAccount)(uid=$1))" sshPublicKey | \e
+	sed 's/sshPublicKey: //'
+exit 0
+.Ed
+.Pp
+And the related configuration in
+.Xr sshd_config 5 :
+.Bd -literal -offset indent
+Match Group ldapusers
+	AuthorizedKeysCommand /etc/ssh/ldap-authorized_keys.sh
+	AuthorizedKeysCommandUser _ldapclient
+.Ed
 .Sh FILES
 .Bl -tag -width "/var/run/ldapd.sockXXXXXXX" -compact
 .It Pa /var/run/ldapd.sock
@@ -92,8 +195,11 @@ control socket
 default
 .Xr ldapd 8
 configuration file
+.It Pa /etc/ssl/cert.pem
+Default CA file for the search client.
 .El
 .Sh SEE ALSO
+.Xr sshd_config 5 ,
 .Xr ldapd.conf 5 ,
 .Xr ldapd 8
 .Sh HISTORY
@@ -101,3 +207,25 @@ The
 .Nm
 program first appeared in
 .Ox 4.8 .
+.Sh STANDARDS
+.Rs
+.%A G. Good
+.%D June 2000
+.%R RFC 2849
+.%T The LDAP Data Interchange Format (LDIF) - Technical Specification
+.Re
+.Pp
+.Rs
+.%A M. Smith, Ed.
+.%A T. Howes
+.%D June 2006
+.%R RFC 4515
+.%T Lightweight Directory Access Protocol (LDAP): String Representation of Search Filters
+.Sh CAVEATS
+The search client does not support SASL authentication;
+authentication should be performed using simple authentication over a
+TLS connection.
+.Pp
+LDAP commonly supports two methods of establishing TLS:
+TLS over LDAP using StartTLS (port 389), and LDAPS (port 636).
+The LDAPS method is currently not supported.
Index: usr.sbin/ldapctl/ldapctl.c
===================================================================
RCS file: /cvs/src/usr.sbin/ldapctl/ldapctl.c,v
retrieving revision 1.11
diff -u -p -u -p -r1.11 ldapctl.c
--- usr.sbin/ldapctl/ldapctl.c	15 May 2018 11:19:21 -0000	1.11
+++ usr.sbin/ldapctl/ldapctl.c	15 May 2018 12:58:19 -0000
@@ -63,6 +63,7 @@ int		 compact_namespaces(const char *dat
 int		 index_namespace(struct namespace *ns, const char *datadir);
 int		 index_namespaces(const char *datadir);
 int		 ssl_load_certfile(struct ldapd_config *, const char *, u_int8_t);
+int		 ldapc_main(int, char *[]);
 
 __dead void
 usage(void)
@@ -304,7 +305,9 @@ main(int argc, char *argv[])
 			action = LOG_BRIEF;
 		else
 			usage();
-	} else
+	} else if (strcmp(argv[0], "search") == 0)
+		return ldapc_main(argc, argv);
+	else
 		usage();
 
 	if (action == COMPACT_DB || action == INDEX_DB) {
